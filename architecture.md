# Architecture

This document details the internal archiecture of the stat-viz project. You do not need an understanding of the internals to add new visualisation components or new data sources. If you are interested in that, please take a look at the instructions in the [README.md](README.md).

## EVM and WebSocket Endpoints

In order to buid visualization for the target EVM, the stat-viz project needs a method to transit the data being collected on the EVM to the web browser on the host machine. We proceed with the assumption that the target EVM is in the same LAN as the host machine.

For data collection, there are two objectives that need to be completed:

1. Collection of Data on the Target EVM
2. Transmission of Data to the Host Machine

The stat-viz project does not make any assumptions about how the data is collected on the target EVM. Instead of a default data representation for the target EVM, it defines a WebSocket Management layer that works on the frontend on the host machine.

It expects that the data will be collected by a process running on the EVM and transmitted to the host frontend through a set of WebSockets. For the purposes of development, we wrote of number of shell scripts for the J7 EVM that can be found in `scripts`.

In order to convert the shell scripts into a WebSocket server, we highly recommend making use of `websocketd`. It is an indepedent program written in Golang that consumes other programs and turns their STDIN/STDOUT into server endpoints.

By using websocketd, we have convert the entire scripts folder into a set of endpoints which can be accessed by the visualization frontend.

## Socket Management

The socket management layer is exposed through the `Sockets` array defined in the [websockets.js](src/websocket.js) file. Each Socket is built according to the following template:

```javascript
const socket = {
  type: type,
  handle: null,
  address: "",
  port: "",
  updaters: [],
  closers: [],
  parser: null,
  samplingInterval: 1.0,
};
```

- `type`: This refers to a unique ID that is used to refer to a particular Socket. The Sockets array defines a `getByType` function which can use the type to get the appropriate Socket object. The type must match the endpoint generated by websocketd. This can be accomplished by naming the input script the same as the type.

- `handle`: This is a reference to the actual WebSocket object. This will be discussed in depth later on.

- `address` + `port`: The address and port of the WebSocket server.

- `updaters`: This is a list of update callbacks. Whenever the WebSocket server transmits data to a socket on the host frontend, each updater attached to the socket is executed. Typically, for a given socket, you would define and attach an update callback for each component that depends on it.

```javascript
(parsedData) => {
  // update callback code
};
```

The updaters take a parsed data from the websocket connection as input. We'll discuss parsedData in detail below.

- `closers`: This is a list of cleanup callbacks. Whenever the socket connection needs to be reset, the cleanup callback is called to reset the state of the component before establishing a new connection. Similar to updaters, you would define and attach a cleanup callback for each component that depends on a given socket.

```javascript
(event) => {
  // cleanup callback code
};
```

The closers take a Close event as input. Typically, the close callback doesn't require the event and the parameter is simply added to make sure the signatures match.

- `parser`: This is a parsing function that reads the data received through the websocket connection and parses it into an appropriate format. This parsed data is then passed to the updaters defined for each socket.

Parsers are defined and exported in the [parsers.js](src/parsers.js) file.

- `samplingInterval`: This is the time interval on which the websocket transmits data from the EVM to the frontend. It is measured in seconds. This value can be changed during operation. The value here is simply a default.

Two methods are defined on the Socket objects.

```javascript
socket.init = (address, port) => {
  socket.address = address;
  socket.port = port;
};

socket.connect = () => {
  if (socket.handle !== null) {
    socket.handle.close();
    socket.handle = null;
  }

  socket.handle = connectToWebSocket(socket);
};
```

The `init` method initializes the address and port values for each Socket object. Since the address and port are taken as input from the host frontend, the host frontend calls the init method whenever the address and port change.

The `connect` method cleans up the components attached to a given socket and re-establishes the socket connection. This method is called when the settings are updated, the connection is manually reset or the address/port changes. All these changes can be made from the host frontend.

## React Components

Along with the socket management layer, the stat-viz project is also designed with highly reusable web components in mind.

These components are defined in the `src/components` directory and depend upon the [Generic](src/components/Generic.js) component.

## App.js
